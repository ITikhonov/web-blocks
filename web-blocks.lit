
		Cascading Style Sheets

	CSS was a quite breakthrough from using &lt;font&gt; tag
	back in 1996. But industry pushes for more and more elaborate
	designs and layouts, well above CSS abilities.

	How many times CSS was damned while hacking 4-column layout
	with floats? Or how many times you put a senseless tag just
	to be able to style things the way needed?

	One of the reasons for CSS to separate presentation from
	information. It did it's job quite well for text styling,
	but failed to provide universal layout mechanism.

	Seems like 15 years from it's invention W3C gave up and resorted
	to ad-hoc layout modules, like tables and columns.

	Still, you have to specify half of design with HTML, half
	with CSS.

	Is this problem solvable at all? Can presentation and data
	be truly separated?

that's not question i am going to answer

		Visual formatting model

limit "weakest point" to block-level elements

too much attack?

	Perhaps, weakest point of CSS is a visual formatting model,
	the thingy which decides where on screen guts of your &lt;div&gt;
	will be.

	Quite complex mechanism described by 115 kilobyte specification,
	not including special layouts like tables. Probably, the chief
	reason of layout incompabilities between browsers is this
	complexity.

	And yet, CSS is quite limiting in what you can actually archive
	with it without resorting to hacks.

		The Question

	Can there be a way to make layouts without it being a tough
	black art?

		What the heck is layout?

define 'blocks'

very unclear paragraph follows

	In the very end of any layout mechanism, all visual blocks on
	page end up being defined by four numbers: top, bottom, left
	and right. They are distance from absolute zero.

note, that bottom and right do not have css meaning.

	<object data="basic.svg" type="image/svg+xml"></object> 

=>basic.svg
-<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="300" width="300">
>	arrows
>	browser-mockup
>	svg-page
>	svg-block1

-	<line x1="80" y1="22" x2="80" y2="48" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="85" y="40">top</text>
-	<line x1="240" y1="22" x2="240" y2="198" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="235" y="125" text-anchor="end">bottom</text>
-	<line x1="22" y1="80" x2="59" y2="80" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="40" y="75" text-anchor="middle">left</text>
-	<line x1="22" y1="160" x2="259" y2="160" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="150" y="155" text-anchor="middle">right</text>

-</svg>

	In Javascript notation, two blocks, 'page' and 'page.block1':

=>test/basic.html

>test-html-pre
-		page = { 
-			top:		20,
-			left:		30, 
-			bottom:		400, 
-			right:		700, 
-		}

-		page.block1 = { 
-			top:		30,
-			left:		50, 
-			bottom:		50, 
-			right:		80, 
-		}
>test-html-post

		Relative

	But in real life block coordinates can't be defined
	directly, as they are a function of content (text size,
	font) or environment (viewport size).

	So block coordinates are mostly specified in terms of
	relation to other blocks.

	<object data="relative.svg" type="image/svg+xml"></object> 

=>relative.svg
-<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="300" width="400">
>	arrows
>	browser-mockup
>	svg-page
>	svg-block1

-	<rect x="230" y="210" width="80" height="50" style="fill:none;stroke:grey;stroke-width:1;"/>
-	<text x="232" y="220" style="fill:grey;font-size:10px">block2</text>

-	<line x1="80" y1="22" x2="80" y2="33" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<line x1="80" y1="36" x2="80" y2="48" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="85" y="40">top</text>

-	<line x1="240" y1="22" x2="240" y2="33" style="stroke: grey;" marker-end="url(#arrowe)"/>
-	<line x1="240" y1="36" x2="240" y2="48" style="stroke: grey;" marker-end="url(#arrowe)"/>
-	<line x1="240" y1="51" x2="240" y2="198" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="235" y="125" text-anchor="end">bottom</text>

-	<line x1="22" y1="80" x2="39" y2="80" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<line x1="41" y1="80" x2="59" y2="80" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="40" y="75" text-anchor="middle">left</text>

-	<line x1="22" y1="160" x2="39" y2="160" style="stroke: grey;" marker-end="url(#arrowe)"/>
-	<line x1="41" y1="160" x2="59" y2="160" style="stroke: grey;" marker-end="url(#arrowe)"/>
-	<line x1="61" y1="160" x2="259" y2="160" style="stroke: black;" marker-end="url(#arrowe)"/>
-	<text x="150" y="155" text-anchor="middle">right</text>


-	<line x1="80" y1="50" x2="80" y2="208" style="stroke: red;" marker-end="url(#arrowe)"/>
-	<line x1="240" y1="200" x2="240" y2="258" style="stroke: red;" marker-end="url(#arrowe)"/>
- 	<line x1="61" y1="80" x2="229" y2="80" style="stroke: red;" marker-end="url(#arrowe)"/>
- 	<line x1="261" y1="160" x2="309" y2="160" style="stroke: red;" marker-end="url(#arrowe)"/>

-	<line x1="230" y1="210" x2="80" y2="210" style="stroke:red;stroke-dasharray:2 2"/>
- 	<line x1="230" y1="210" x2="230" y2="80" style="stroke:red;stroke-dasharray:2 2"/>
- 	<line x1="310" y1="210" x2="310" y2="160" style="stroke:red;stroke-dasharray:2 2"/>
-</svg>

=>test/relative.html

>test-html-pre
-		page = { 
-			top:		20,
-			left:		20,
-			right:		'(- document.body.clientWidth 20)',
-			bottom:		400,
-		}

-		page.block1 = {
-			top:	'page.top',
-			left:	'(+ page.left 20)',
-			bottom:	'(+ page.block1.top 100)',
-			right:	'(+ page.block1.left 120)',
-		}

-		page.block2 = {
-			top:	'(+ page.block1.bottom 5)',
-			left:	'(- page.block1.right 5)',
-			bottom:	'(+ page.block2.top 50)',
-			right:	'(+ page.block2.left 75)',
-		}
>test-html-post

	Right edge of page block is defined relative to viewport
	width and so on. Position of block2 depends on block1 position
	and size.

		Block content size

	For some blocks their content is used to determine bottom
	and right coordinates.

=>test/content.html

>test-html-pre

-		page = { 
-			top:		20,
-			left:		20,
-			bottom:		700,
-			right:		700,
-		}

-		page.block1 = {
-			top:	'(+ page.top 20)',
-			left:	'(+ page.left 20)',
-			right:	'(+ page.block1.left 30)',
-			bottom:	'(+ page.block1.top (+ page.block1.contentHeight 20))',
-			html:	'block1 Hello, world!'
-		}

-		page.block1.block2 = {
-			top:	'(+ page.block1.top 20)',
-			left:	'(+ page.block1.left 30)',
-			right:	'(+ page.block1.block2.left page.block1.block2.contentWidth)',
-			bottom:	'(+ page.block1.block2.top page.block1.block2.contentHeight)',
-			html:	'block2 Hello, world!'
-		}

>test-html-post

		Typical layouts

	So can this very simplistic approach be at least comparable to css?
	Let's start with classical three-column layout, widths 25%, 50% and
	25% again, equal height.

		Some sugar

	First some syntactic sugar to improve readability.

	Instead of refering to block by full name single <code>.</code> can be written.
	Two rows below are equivalent.

	<pre>
	page.block1.block2.right = '(+ page.block1.block2.left 10)';
	page.block1.block2.right = '(+ .left 10)';
	</pre>

	To refer to parent block use two dots.

	<pre>
	page.block1.block2.top = 'page.block1.top';
	page.block1.block2.top = '..top';
	</pre>

	Blocks can be put into array. Last and first elements in array
	are addressable. Elements inside of array can address .next and .prev
	elements.

	<pre>
	c2.top = '.prev.top';
	c2.top = '.next.bottom';

	page.c = [c1,c2,c3];
	page.top = '.c.first.top';
	page.bottom = '.c.last.bottom';
	</pre>


	Common calculations can be specified with separate property, which obey
	ordinary rules.

	<pre>
	page.halfpage = '(* 0.5 (.right - .left))';
	page.pad = 20
	page.block1.right = '(+ ..pad .left page.halfpage)';
	page.block2.right = '(+ ..pad .left page.halfpage)';
	</pre>

		Three columns

=>test/threecolumn.html

>test-html-pre
>lorem

-		page = { 
-			top:		20,
-			left:		20,
-			right:		'(- document.body.clientWidth 20)',
-			bottom:		'.c1.bottom',
-		}

-		page.c1 = {
-			top:	'..top',
-			left:	'..left',
-			bottom:	'(+ .top (max ..c1.contentHeight ..c2.contentHeight ..c3.contentHeight))',
-			right:	'(+ .left (* 0.25 (- ..right ..left)))',
-			html: lorem
-		}

-		page.c2 = {
-			top:	'..top',
-			left:	'..c1.right',
-			bottom:	'(+ .top (max ..c1.contentHeight ..c2.contentHeight ..c3.contentHeight))',
-			right:	'(+ .left (* 0.50 (- ..right ..left)))',
-			html: lorem
-		}

-		page.c3 = {
-			top:	'..top',
-			left:	'..c2.right',
-			bottom:	'(+ .top (max ..c1.contentHeight ..c2.contentHeight ..c3.contentHeight))',
-			right:	'(+ .left (* 0.25 (- ..right ..left)))',
-			html: lorem
-		}

>test-html-post
	

		Catalog view

	Thing, that displays as much 128x128 elements as it can in a row,
	wraps rest nicely, but maintains alignment to both left and right side
	of the page. Can this be done with CSS?

=>test/catalog.html

>test-html-pre

-		page = { 
-			top:	20,
-			left:	20,
-			right:	'(- document.body.clientWidth 20)',
-			bottom:	'.c.last.bottom',

-			w:	128,
-			h:	128,

	Calculate how much items can be hold in a row

-			n:	'(floor (/ (- .right .left) .w))',

	Calculate offset from one item to another

-			dx:	'(/ (- (- .right .w) .left) (- .n 1))'
-		}

-		page.c = [{
-			top:	'..top',
-			left:	'..left',
-			right:	'(+ .left ..w)',
-			bottom:	'(+ .top ..h)',
-			html:	'block0'
-		}]

	They are identical except of html.

-		for(var i=1;i<24;i++) {
-			page.c.push({
-				top: '(+ .prev.top (? .cond 0 140))',
-				left: '(? .cond .maybe ..left)',
-				right:	'(+ .left ..w)',
-				bottom:	'(+ .top ..h)',

-				cond:'(< (- (+ .maybe ..w) 0.01) ..right)',
-				maybe:'(+ .prev.left ..dx)',

-				html: 'block'+i
-			});
-		}

>test-html-post
	
		Implementation


		Lisp parser

	You may wonder why Lisp-ish syntax. Well, between spending time
	writing parser and writing whole thing i chose latter.

	It was raw javascript at first, but then algorithm demanded all
	identifiers for dependencies.

=lisp-parser
-function parse_sexpr(s) {
-	if(typeof s=='number') return s;
-	stack=[[]]
-	tokens=s.match(/\(|\)|[^\s)(]+/g)
-	for(var x in tokens) {
-		x=tokens[x];
-		if(x=='(') {
-			stack.push([]);
-		} else if(x==')') {
-			stack[stack.length-2].push(stack.pop());
-		} else {
-			var f=parseFloat(x);
-			if(!isNaN(f)) x=f;
-			stack[stack.length-1].push(x);
-		}
-	}
-	return stack[0][0];
-}


		Lisp functions

=lisp-math
-var lisp={
-	'+':function() { var s=arguments[0]; for(var i=1;i<arguments.length;i++) s+=arguments[i]; return s; },
-	'-':function() { var s=arguments[0]; for(var i=1;i<arguments.length;i++) s-=arguments[i]; return s; },
-	'*':function() { var s=arguments[0]; for(var i=1;i<arguments.length;i++) s*=arguments[i]; return s; },
-	'?':function(a,b,c) { return a?b:c; },
-	'%':function(a,b) { return a%b; },
-	'/':function(a,b) { return a/b; },

-	'max':Math.max,
-	'min':Math.min,
-	'floor':Math.floor,
-	'dump':function(a) { console.log(arguments); return a; },

-	'<':function(a,b) { return a<b; },
-	'>':function(a,b) { return a>b; },
-	'=':function(a,b) { return a==b; },
-}

=compile-lisp
-function compile_lisp(s,deps) {
-	if(s instanceof Array) {
-		var f=lisp[s[0]];
-		var a=[];
-		for(var i=1;i<s.length;i++) { a.push(compile_lisp(s[i],deps)); }
-		return function() {
-			var v=[];
-			for(var i in a) { v.push(a[i].apply(this)); }
-			return f.apply(this,v);
-		}
-	}
-
-	if(typeof(s)!='number') {
-		var dots=s.match(/^\.+/);
-		if(dots) {
-			dots=dots[0].length;
-			s='this.'+(new Array(dots).join('_.'))+s.slice(dots);
-		}
-		deps.push(s);
-		if(s=='this.contentHeight' || s=='this.contentWidth') {
-			deps.content=true;
-		}
-		return (function() { return eval(s); });
-	}
-	return (function() { return s; });
-}

		Layout engine

		Walking

=each-block
-function each_block(block,func) {
-	for(var k in block) {
-		if(k[0]=='_') continue;
-		if(k=='top') continue;
-		if(k=='left') continue;
-		if(k=='right') continue;
-		if(k=='bottom') continue;
-		if(k=='contentWidth') continue;
-		if(k=='contentHeight') continue;

-		if(block[k] instanceof Array) {
-			for(var i in block[k]) {
-				func(block[k][i],k);
-			}
-		} else if(typeof block[k]=='object') {
-			func(block[k],k);
-		}
-	}
-}


-function walk_block(f,k,block,z,path,parent) {
-	var d=0;
-	path.push(k);
-	var n=each_block(block,function(b,k) {  d+=walk_block(f,k,b,z+1,path,block); });
-	d+=f(block,path,z,parent);
-	path.pop(k); 
-	return d;
-}

-function walk_all(f,k,block) {
-	return walk_block(f,k,block,0,[],null);
-}


		Parsing

=parse-block
-function parse_block(b,_,_,parent) {
-	b._=parent;
-	b._deps={};
-	b._func={};
-	b._source={};

-	for(var k in b) {
-		if(k[0]=='_') continue;
-		if(k=='html') continue;

-		if(typeof(b[k])=='string' || typeof(b[k])=='number') {
-			b._source[k]=parse_sexpr(b[k]);
-			b[k]=undefined;
-			b._deps[k]=[];
-			b._func[k]=compile_lisp(b._source[k],b._deps[k]);
-		} else if(b[k] instanceof Array) {
-			b[k].last=b[k][b[k].length-1];
-			b[k].first=b[k][0];
-			for(var i=0;i<b[k].length;i++) {
-				Object.defineProperty(b[k][i],'prev',{
-					value:b[k][i-1],enumerable:false
-				});
-				Object.defineProperty(b[k][i],'next',{
-					value:b[k][i+1],enumerable:false
-				});
-			}
-		}
-	}

-}

		Resolving coordinates

	To convert relative coordinates into absolute we check
	each coordinate:

	0. if it already has a value, skip

	1. otherwise remove from dependencies all values
	which are already calculated.

	2. if it has no dependencies, calculate value

	3. repeat

=resolve-block
-function _eval(s,_) {
-	return eval(s);
-}

-function resolve_coord(b,f) {
-	if(b[f]==undefined) {
-		for(var i=0;i<b._deps[f].length;) {
-			var x=b._deps[f][i];
-			if(_eval.call(b,x)!=undefined) {
-				b._deps[f].splice(i,1);
-				continue;
-			}
-			i++;
-		}
-		if(b._deps[f].length==0) {
-			b[f]=b._func[f].call(b);
-		}
-	}
-	return b._deps[f].length?1:0;
-}

-function resolve_block(b,path,z) {
-	var d=0;

-	for(k in b._deps) {
-		d+=resolve_coord(b,k);
-	}

	Sometimes, the only way to resolve block is to compute
	it's content (like when right and bottom depend on content).

Looks like there is a bug. We now not only have these four lispy things, but
may be more, differently named. Also it does not handle situation when edges
depend on something which in turn depend on content.

-	var cd=0;
-	if(b._deps.top.content) cd++;
-	if(b._deps.left.content) cd++;
-	if(b._deps.right.content) cd++;
-	if(b._deps.bottom.content) cd++;

	If we have left&right or top&bottom - we are ready to
	compute content.

-	var cr=(b.left&&b.right) || (b.top&&b.bottom);

-	if(cr || (d && cd==d)) {
-		render_html(b,path,z);
-		b.contentWidth=b._el.scrollWidth;
-		b.contentHeight=b._el.scrollHeight;
-	}

-	return d;
-}



		Generate HTML

=bake-block
-function render_html(block,path,z) {
-	if(!block._el) {
-		block._el=document.createElement('div');
-	}
-	block._el.className='apos';
-	block._el.style.zIndex=z;
-	block._el.innerHTML	=block.html?block.html:'';
-	block._el.id=path.join('.');

-	block._el.style.top	=block.top;
-	block._el.style.height	=block.bottom - block.top;
-	block._el.style.left	=block.left;
-	block._el.style.width	=block.right - block.left;

-	if(!block._el.parentNode) {
-		document.body.appendChild(block._el);
-	}
-}

		Report unresolved

=report-unresolved
-function report_unresolved_field(b,f,name) {
-	if(b[f]==undefined) {
-		console.log('unresolved',name+'.'+f,'because of',b._deps[f]);
-	}
-}

-function report_unresolved(block,path) {
-	name=path.join('.');
-	report_unresolved_field(block,'top',name);
-	report_unresolved_field(block,'left',name);
-	report_unresolved_field(block,'right',name);
-	report_unresolved_field(block,'bottom',name);
-}

		Main

=>main.js
-(function() {

>lisp-parser
>lisp-math
>compile-lisp

>each-block
>parse-block
>resolve-block
>bake-block
>report-unresolved

-function parse() { walk_all(parse_block,'page',page); }
-function bake() { walk_all(render_html,'page',page); }
-function run() {
-	parse();
-	var i;
-	for(i=0;i<300;i++) { if(walk_all(resolve_block,'page',page)==0) break; }
-	if(i==300) {
-		walk_all(report_unresolved,'page',page);
-	}
-	bake();
-}
-window.onload=run;

-})();

		Test

=test-html-pre
-<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><style>.apos{position:absolute;margin:0;padding:0;border:1px solid black;overflow:hidden}</style></head><script>

=test-html-post
-</script><script src="../main.js"></script><body></body></html>

=lorem
-		var lorem='<div style="padding:1em">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</div>';

		SVG utilities

=browser-mockup
-<text x="47" y="5" text-anchor="start">http://brokestream.com/|</text>
-<rect x="24" y="-24" width="20" height="30" style="fill:none;stroke:grey;stroke-width:1;"/>
-<rect x="20" y="-20" width="400" height="30" style="fill:none;stroke:grey;stroke-width:1;"/>
-<rect x="16" y="-20" width="400" height="700" style="fill:none;stroke:grey;stroke-width:1;"/>
-<rect x="20" y="20" width="400" height="300" style="fill:none;stroke:grey;stroke-width:1;"/>

=arrows
-<defs>
-	<marker id="arrowe" refX="5" refY="5" markerWidth="10" markerHeight="10" orient="auto">
-		<line x1="0" y1="0" x2="5" y2="5" style="stroke-width:1;stroke: black;"/>
-		<line x1="5" y1="5" x2="0" y2="10" style="stroke-width:1;stroke: black;"/>
-	</marker>
-</defs>

=svg-page
-	<rect x="40" y="35" width="400" height="350" style="fill:none;stroke:grey;stroke-width:1;"/>
-	<text x="42" y="45" style="fill:grey;font-size:10px">page</text>

=svg-block1
-	<rect x="60" y="50" width="200" height="150" style="fill:none;stroke:grey;stroke-width:1;"/>
-	<text x="62" y="60" style="fill:grey;font-size:10px">block1</text>

