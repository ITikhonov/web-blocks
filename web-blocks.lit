		Lisp parser

=lisp-parser
-function parse_sexpr(s) {
-	if(typeof s=='number') return s;
-	stack=[[]]
-	tokens=s.match(/\(|\)|[^\s)(]+/g)
-	for(var x in tokens) {
-		x=tokens[x];
-		if(x=='(') {
-			stack.push([]);
-		} else if(x==')') {
-			stack[stack.length-2].push(stack.pop());
-		} else {
-			var f=parseFloat(x);
-			if(!isNaN(f)) x=f;
-			stack[stack.length-1].push(x);
-		}
-	}
-	return stack[0][0];
-}


		Lisp functions

=lisp-math
-var lisp={
-	'+':function(a,b) { return a+b; }
-}

		Block coordinates

	Each block is rectangular area, which have top,
	left, bottom and right coordinates relative to
	page.

	So at the very core each block looks like:

=test-block-basic
-		page = { 
-			top:		20,
-			left:		30, 
-			bottom:		400, 
-			right:		700, 
-		}

-		page.block1 = { 
-			top:		30,
-			left:		50, 
-			bottom:		50, 
-			right:		80, 
-		}


	But in real life block coordinates can't be defined
	directly, as they are function of content (text size)
	or environment (font, viewport size).

	So block coordinates are mostly specified in terms of
	relation to other blocks.


=test-block-relative
-		page = { 
-			top:		20,
-			left:		20, 
-			bottom:		1010, 
-			right:		700, 
-		}

-		page.block1 = {
-			top:	'page.top',
-			left:	'(+ page.left 20)',
-			bottom:	'(+ page.block1.top 100)',
-			right:	'(+ page.block1.left 120)',
-		}

-		page.block2 = {
-			top:	'page.block1.bottom',
-			left:	'page.block1.right',
-			bottom:	'(+ page.block2.top 50)',
-			right:	'(+ page.block2.left 75)',
-		}

	Position of block2 depends on block1 position and size.

=compile-lisp
-function compile_lisp(s) {
-	if(s instanceof Array) {
-		var f=lisp[s[0]];
-		var a=[];
-		for(var i=1;i<s.length;i++) { a.push(compile_lisp(s[i])); }
-		return function() {
-			var v=[];
-			for(var i in a) { v.push(a[i].apply(this)); }
-			return f.apply(this,v);
-		}
-	}
-	return (function() { return s; });
-}

		Block content

	Empty blocks are almost useless.

=test-block-html
-		page = { 
-			top:		20,
-			left:		20, 
-			bottom:		1010, 
-			right:		700, 
-		}

-		page.block1 = {
-			top:	'page.top',
-			left:	'page.left + 20',
-			bottom:	'page.block1.top + 100',
-			right:	'page.block1.left + 120',
-		}

-		page.block2 = {
-			top:	'page.block1.bottom',
-			left:	'page.block1.right',
-			bottom:	'page.block2.top + 50',
-			right:	'page.block2.left + 75',
-			html:	'Hello, world!'
-		}





		Block content size

	For some blocks their content is used to determine bottom
	and right coordinates.

	For each block content.bottom and content.right specifies
	maximum bottom and right coordinates of blocks it includes.

=test-block-content
-		page = { 
-			top:		20,
-			left:		20,
-			bottom:		'page.contentBottom',
-			right:		700,
-		}

-		page.block1 = {
-			id: 'page.block1',
-			top:	'page.top + 20',
-			left:	'page.left + 20',
-			bottom:	'page.block1.contentBottom + 20',
-			right:	'page.block1.contentRight + 30',
-		}

-		page.block1.block2 = {
-			id: 'page.block1.block2',
-			top:	'page.block1.top + 20',
-			left:	'page.block1.left + 30',

	No bottom and right coordinates - will size it by content.

-			html:	'Hello, world!'
-		}

		Walking

=each-block
-function each_block(block,func) {
-	for(var k in block) {
-		if(k[0]=='_') continue;
-		if(k=='top') continue;
-		if(k=='left') continue;
-		if(k=='right') continue;
-		if(k=='bottom') continue;
-		if(typeof block[k]!='object') continue;
-		func(block[k],k);
-	}
-}

		Parsing

	For convenience relative coordinates are given as sexpr in
	string, so we parse it before processing.

=parse-block
-function parse_block(b) {
-	each_block(b,parse_block)
-	b.top=parse_sexpr(b.top);
-	b.left=parse_sexpr(b.left);
-	b.right=parse_sexpr(b.right);
-	b.bottom=parse_sexpr(b.bottom);

-		

-}

		Evaluating coordinates

	Converting relative coordinates into absolute.

=eval_block
function



		Generate HTML

=bake-block
-function bake_block(k,block,z,path) {
-	path.push(k);

-	var n=each_block(block,function(b,k) {  bake_block(k,b,z+1,path); });

-	block._el=document.createElement('div');
-	block._el.className='apos';
-	block._el.style.zIndex=z;
-	block._el.innerHTML	=block.html?block.html:'';
-	block._el.id=path.join('.');

-	block._el.style.top	=block.top;
-	block._el.style.height	=block.bottom - block.top;
-	block._el.style.left	=block.left;
-	block._el.style.width	=block.right - block.left;
-	document.body.appendChild(block._el);

-	path.pop(k); 
-}

=>main.js
(function()

>lisp-parser
>lisp-math
>compile-lisp

>each-block
>parse-block
>bake-block

-function bake() { bake_block('page',page,0,[]); }
-function run() { parse_block(page); bake(); }
-window.onload=run;

)();

=test-html-pre
-<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><style>.apos{position:absolute;margin:0;padding:0;border:1px solid black;overflow:hidden}</style></head><script>

=test-html-post
-</script><script src="../main.js"></script><body></body></html>

=>test/basic.html
>test-html-pre
>test-block-basic
>test-html-post


=>test/relative.html
>test-html-pre
>test-block-relative
>test-html-post

=>test/html.html
>test-html-pre
>test-block-html
>test-html-post
 
=>test/content.html
>test-html-pre
>test-block-content
>test-html-post
 
